"""
Real-Time Transaction Monitor for MyBank

Monitors all transactions in real-time for fraud detection.
Generated by Code Agent
"""
import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Callable, Optional
from dataclasses import dataclass

try:
    from .fraud_detector import FraudDetector, Transaction, FraudScore
except ImportError:
    # Fallback for standalone usage
    FraudDetector = None
    Transaction = None
    FraudScore = None

logger = logging.getLogger(__name__)


@dataclass
class MonitoringAlert:
    """Alert generated by transaction monitoring."""
    alert_id: str
    transaction_id: str
    customer_id: str
    alert_type: str
    severity: str
    message: str
    timestamp: datetime
    fraud_score: float
    recommended_action: str


class TransactionMonitor:
    """
    Real-time transaction monitoring service with fraud detection.
    """
    
    def __init__(self, fraud_detector: FraudDetector = None):
        """Initialize transaction monitor."""
        self.fraud_detector = fraud_detector or FraudDetector()
        self.alert_handlers: List[Callable] = []
        self.monitoring_active = False
        self.processed_count = 0
        self.alert_count = 0
        self.logger = logger
    
    def add_alert_handler(self, handler: Callable[[MonitoringAlert], None]):
        """Add alert handler callback."""
        self.alert_handlers.append(handler)
    
    def start_monitoring(self):
        """Start real-time transaction monitoring."""
        self.monitoring_active = True
        self.logger.info("Transaction monitoring started")
    
    def stop_monitoring(self):
        """Stop transaction monitoring."""
        self.monitoring_active = False
        self.logger.info("Transaction monitoring stopped")
    
    async def process_transaction(self, transaction_data: Dict[str, Any], 
                                customer_history: List[Dict[str, Any]] = None) -> MonitoringAlert:
        """
        Process a single transaction for fraud detection.
        
        Args:
            transaction_data: Transaction details
            customer_history: Recent customer transaction history
            
        Returns:
            Monitoring alert if generated
        """
        if not self.monitoring_active:
            return None
        
        try:
            # Convert to Transaction object
            transaction = self._dict_to_transaction(transaction_data)
            
            # Convert history if provided
            history = []
            if customer_history:
                history = [self._dict_to_transaction(t) for t in customer_history]
            
            # Analyze for fraud
            fraud_score = self.fraud_detector.analyze_transaction(transaction, history)
            
            # Generate alert if necessary
            alert = self._generate_alert_if_needed(transaction, fraud_score)
            
            # Increment processed count
            self.processed_count += 1
            
            # Log processing
            self.logger.debug(
                f"Processed transaction {transaction.id}: "
                f"score={fraud_score.score:.3f}, level={fraud_score.risk_level}"
            )
            
            # Send alerts to handlers
            if alert:
                await self._send_alert(alert)
            
            return alert
            
        except Exception as e:
            self.logger.error(f"Error processing transaction: {e}")
            raise
    
    def _dict_to_transaction(self, data: Dict[str, Any]) -> Transaction:
        """Convert dictionary to Transaction object."""
        return Transaction(
            id=data["id"],
            customer_id=data["customer_id"],
            amount=data["amount"],
            merchant=data["merchant"],
            location=data["location"],
            timestamp=data.get("timestamp", datetime.now()),
            card_number_hash=data["card_number_hash"],
            transaction_type=data["transaction_type"],
            metadata=data.get("metadata", {})
        )
    
    def _generate_alert_if_needed(self, transaction: Transaction, 
                                fraud_score: FraudScore) -> Optional[MonitoringAlert]:
        """Generate monitoring alert if thresholds are met."""
        # Only alert on medium risk and above
        if fraud_score.risk_level in ["MEDIUM", "HIGH", "CRITICAL"]:
            alert = MonitoringAlert(
                alert_id=f"ALERT_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{transaction.id}",
                transaction_id=transaction.id,
                customer_id=transaction.customer_id,
                alert_type="FRAUD_RISK",
                severity=fraud_score.risk_level,
                message=f"Fraud risk detected: {', '.join(fraud_score.factors)}",
                timestamp=datetime.now(),
                fraud_score=fraud_score.score,
                recommended_action=fraud_score.recommendation
            )
            
            self.alert_count += 1
            return alert
        
        return None
    
    async def _send_alert(self, alert: MonitoringAlert):
        """Send alert to all registered handlers."""
        for handler in self.alert_handlers:
            try:
                if asyncio.iscoroutinefunction(handler):
                    await handler(alert)
                else:
                    handler(alert)
            except Exception as e:
                self.logger.error(f"Error in alert handler: {e}")
    
    def get_monitoring_stats(self) -> Dict[str, Any]:
        """Get current monitoring statistics."""
        return {
            "monitoring_active": self.monitoring_active,
            "processed_transactions": self.processed_count,
            "alerts_generated": self.alert_count,
            "alert_rate": self.alert_count / max(self.processed_count, 1),
            "uptime": "active" if self.monitoring_active else "stopped"
        }
    
    async def bulk_process_transactions(self, transactions: List[Dict[str, Any]]) -> List[MonitoringAlert]:
        """Process multiple transactions in batch."""
        alerts = []
        
        for transaction_data in transactions:
            alert = await self.process_transaction(transaction_data)
            if alert:
                alerts.append(alert)
        
        self.logger.info(f"Bulk processed {len(transactions)} transactions, generated {len(alerts)} alerts")
        return alerts


# Example alert handlers
def console_alert_handler(alert: MonitoringAlert):
    """Simple console alert handler."""
    print(f"ðŸš¨ FRAUD ALERT: {alert.severity} risk for transaction {alert.transaction_id}")
    print(f"   Customer: {alert.customer_id}")
    print(f"   Score: {alert.fraud_score:.3f}")
    print(f"   Recommendation: {alert.recommended_action}")
    print(f"   Message: {alert.message}")


async def async_alert_handler(alert: MonitoringAlert):
    """Async alert handler for external system integration."""
    # Simulate external system call
    await asyncio.sleep(0.1)
    logger.info(f"Sent alert {alert.alert_id} to external fraud management system")
